% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/test.clusters.MC.R
\name{test.clusters.MC}
\alias{test.clusters.MC}
\title{Test for the difference of two cluster means after any clustering algorithm, for matrix normal model with arbitrary scale matrices.}
\usage{
test.clusters.MC(
  X,
  U = NULL,
  Sigma = NULL,
  Y = NULL,
  UY = NULL,
  precUY = NULL,
  clusters,
  cl_fun,
  NC = NULL,
  cl = NULL,
  ndraws = 2000
)
}
\arguments{
\item{X}{A \eqn{n \times p} matrix drawn from a \eqn{n \times p} matrix normal distribution \eqn{\mathcal{MN}(}\code{M}, \code{U}, \code{Sigma}\eqn{)}. \code{X} must have \eqn{n} rows and \eqn{p} columns.}

\item{U}{A \eqn{n \times n} positive-definite matrix describing the dependence structure between the rows in \code{X}. If \code{NULL}, observations are considered independent and \code{U} is set to the \eqn{n \times n} identity matrix.}

\item{Sigma}{A \eqn{p \times p} positive-definite matrix describing the dependence structure between the columns in \code{X}. If \code{NULL}, \code{Sigma} is over-estimated (in the sense of the Loewner partial order).}

\item{Y}{If \code{Sigma} is \code{NULL}, an i.i.d. copy of \code{X} allowing its estimation. \code{Y} must have the same number of columns as \code{X}.}

\item{UY}{If \code{Sigma} is \code{NULL}, a positive-definite matrix describing the dependence structure between the rows in \code{Y}. If \code{NULL} and its inverse is not provided, set to the identity matrix by default.}

\item{precUY}{The inverse matrix of \code{UY}, that can be provided to increase computational efficiency. If \code{UY} is not \code{NULL} and \code{precUY} is \code{NULL}, \code{precUY} is obtained by inverting \code{UY}.}

\item{clusters}{A vector of two integers from 1 to \code{NC} indicating the pair of clusters whose means have to be compared.}

\item{cl_fun}{A function returning assignments to clusters. The function must take as input the data matrix \code{X} and the number of clusters \code{NC}.}

\item{NC}{The number of clusters to choose, that will be passed as argument to \code{cl_fun}. Must be set to \code{NULL} if not required by \code{cl_fun}.}

\item{cl}{The result of clustering \code{X} using \code{cl_fun}. It can useful to precompute this quantity before choosing \code{clusters}.}

\item{ndraws}{The number of Monte Carlo iterations.}
}
\value{
\itemize{
  \item pvalue - The p-value for the difference of cluster means.
  \item stat - The test statistic.
  \item stdrr - The Monte Carlo standard error.
  \item clusters - The partition of the \code{n} observations retrieved by the clustering algorithm.
}
}
\description{
Test for the difference of two cluster means after any clustering algorithm, for matrix normal model with arbitrary scale matrices.
}
\examples{

n <- 50
p <- 20
M <- Matrix::Matrix(0, nrow = n , ncol = p) # Mean matrix
Sigma <- stats::toeplitz(seq(1, 0.1, length = p)) # Sigma: dependence between features
U <- matrixNormal::I(n) # U: dependence between observations
X <- matrixNormal::rmatnorm(s = 1, M, U, Sigma)
Y <- matrixNormal::rmatnorm(s = 1, M, U, Sigma) # i.i.d. copy of X

# Using HDBSCAN clustering from dbscan package. This algorithm selects 
# automatically the number of clusters NC.
# Additional clustering parameters must be set as default values
# when defining cl_fun.

# install.packages('dbscan')

hdbscan.clustering <- function(X, NC = NULL, min.occupancy = 5){
 
 X.clus <- dbscan::hdbscan(X, minPts = min.occupancy)
 return(X.clus$cluster + 1)
 
}

# We start by clustering the data
clusters_X <- hdbscan.clustering(X)
# We test for the equality of clusters 3 and 1
test.clusters.MC(X, U = U, Sigma = Sigma, clusters = c(3,1),
 cl = clusters_X, cl_fun = hdbscan.clustering, NC = NULL, ndraws = 500)

}
\references{
[1] L. L. Gao, J. Bien, and D. Witten. Selective inference for hierarchical clustering. Journal of the American Statistical Association, 0(0):1â€“11, 2022.
}
